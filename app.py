# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17ryX2vMbhGo--gOOPwVfhx9Y7h920gNl
"""

import streamlit as st

# üß† Define memory class
class Memory:
    def __init__(self):
        self.episodic_memory = []
        self.semantic_memory = {}

    def store_episode(self, episode):
        self.episodic_memory.append(episode)

    def store_fact(self, key, value):
        self.semantic_memory[key.lower().strip()] = value

    def recall_fact(self, key):
        return self.semantic_memory.get(key.lower().strip(), "I don't know that yet.")

# üß† Initialize memory (persists per session)
if 'memory' not in st.session_state:
    st.session_state.memory = Memory()

memory = st.session_state.memory

# üß† Streamlit UI
st.title("üß† AI Memory Agent")
st.write("Ask me a question, or teach me something using the format: `teach [key] [value]`.")

# User input
user_input = st.text_input("You:", "")

if user_input:
    memory.store_episode(f"User: {user_input}")

    # Teaching mode
    if user_input.lower().startswith("teach "):
        try:
            teach_content = user_input[6:].strip()  # remove "teach "
            
            # Handle "is" as optional
            if " is " in teach_content:
                key, value = teach_content.split(" is ", 1)
            else:
                parts = teach_content.rsplit(" ", 1)
                if len(parts) != 2:
                    raise ValueError("Invalid format")
                key, value = parts
    
            key = key.strip()
            value = value.strip()
    
            memory.store_fact(key, value)
            response = f"Got it! I've learned that '{key}' is '{value}'."
        except Exception as e:
            response = "‚ö†Ô∏è Format error. Use: teach [key] [value] or teach [key] is [value]"

    # Asking mode
    else:
        key = user_input.lower().replace("what is ", "").replace("who is ", "").replace("where is ", "").replace("when is ", "").strip()
        response = memory.recall_fact(key)

    memory.store_episode(f"Agent: {response}")
    st.markdown(f"**Agent:** {response}")

# üìÇ Semantic Memory
with st.expander("üóÇÔ∏è Semantic Memory"):
    for k, v in memory.semantic_memory.items():
        st.write(f"**{k}** ‚Üí {v}")

# üìú Episodic Memory
with st.expander("üìú Episodic Memory"):
    for e in memory.episodic_memory:
        st.write(e)
